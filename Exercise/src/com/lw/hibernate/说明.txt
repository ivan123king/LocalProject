学习hibernate的目录
HibernateTest是一个单元测试类
最简单的结构：
	News.java  News.hbm.xml hibernate.cfg.xml HibernateTest.java
1. 使用如下方式获取Session
	Configuration configuration = new Configuration().configure();
	ServiceRegistry serviceRegistry = new ServiceRegistryBuilder().applySettings(configuration.getProperties())
			.buildServiceRegistry();
	SessionFactory sessionFactory = configuration.buildSessionFactory(serviceRegistry);
	Session session = sessionFactory.openSession();
	Transaction transaction = session.beginTransaction();

2.操作对象
a)获取对象	News news = (News) session.get(News.class, 1);
b)保存对象	session.save(news);
c)根据数据库记录更新session缓存	session.refresh(news);
d)根据session缓存更新数据库记录	session.flush()
e)更新对象	session.update(news)
	此处需要注意如果不是在同一个session中调用update方法，无论对象是否改变都会发送updateSQL给数据库
	以保证对象更新
	eg.
	News news = (News) session.get(News.class, 1);
	transaction.commit();
	session.close();
	session = sessionFactory.openSession();
	transaction = session.beginTransaction();
	session.update(news);
	在News.hbm.xml中class节点设置select-before-update="true"让Hibernate在update时select下确定对象是否改变
f) session.saveOrUpdate(news);主键ID不为空update,为空save
g) session.delete(news) 根据OID删除对象
h) session.evict(news) 从session缓存中将对应的持久化对象移出
i) session.doWork(new Work() {
			@Override
			public void execute(Connection conn) throws SQLException {
				这里获取原生的JDBC connection操作数据库
				Hibernate自己没有办法获取到Connection
			}
		});




3.提交，关闭session
	transaction.commit();  ----提交前会先调用 flush方法校验缓存
	session.close();
	sessionFactory.close();

session.get()立即加载
session.load()懒加载，返回代理对象


hibernate.cfg.xml相关：
配置c3p0数据源：
1.添加jar包：
	hibernate-release-5.2.12.Final\lib\optional\c3p0   此处是jar包
		c3p0-0.9.5.2.jar
		hibernate-c3p0-5.2.12.Final.jar
		mchange-commons-java-0.2.11.jar
2. hibernate.cfg.xml中配置如下：
	hibernate.c3p0.max_size: 数据库连接池的最大连接数
	hibernate.c3p0.min_size: 数据库连接池的最小连接数
	hibernate.c3p0.timeout:   数据库连接池中连接对象在多长时间没有使用过后，就应该被销毁  单位：毫秒
	hibernate.c3p0.max_statements:  缓存 Statement 对象的数量
	hibernate.c3p0.idle_test_period:  表示连接池检测线程多长时间检测一次池内的所有链接对象是否超时. 
									连接池本身不会把自己从连接池中移除，而是专门有一个线程按照一定的时间间隔来做这件事，
									这个线程通过比较连接对象最后一次被使用时间和当前时间的时间差来和 timeout 做对比，
									进而决定是否销毁这个连接对象。 
									单位：毫秒
	hibernate.c3p0.acquire_increment: 当数据库连接池中的连接耗尽时, 同一时刻获取多少个数据库连接

hibernate.jdbc.fetch_size  一次查询多少条数据出来   （分页）
hibernate.jdbc.batch_size  一次批量保存，更新或者删除多少数据
PS：上述两项配置对Mysql无效，对oracle有效

更多了解看hibernate自带的手册：hibernate-release-5.2.12.Final\documentation\userguide\html_single

*.hbm.xml文件相关：
	column节点sql-type可以指定表字段类型

	*.hbm.xml中generator节点如果使用native而不是sequence，
		对应oracle数据库时需要一个序列hibernate_sequence，
		这需要自建否则插入oracle数据库中报错
		
		native 根据本地策略自动选择生成主键方式
	
	看News.hbm.xml中，新增一个desc变量，但是这个desc变量没有对应数据库字段，而是在查询是对应一些特定方式，使用formula
	<!-- 映射派生属性 -->
	<property name="desc" type="java.lang.String" formula="(select concat(title,':',author) from News n where n.id=id)"></property>
	PS: 此处的  n.id = id 一定需要n. 否则如果是id=id 会报错： org.hibernate.exception.DataException: could not extract ResultSet        
		formula=“(sql)” 的英文括号不能少
		Sql 表达式中的列名和表名都应该和数据库对应, 而不是和持久化对象的属性对应
	

时间类型对应：
	Hibernate		Java				SQL
	date 			java.sql.Date		DATE
	time			java.sql.Time		TIME
	timestamp		java.sql.Timestamp	TIMESTAMP
	calendar		java.util.Calendar	TIMESTAMP
	calendar_date	java.util.Calendar	DATE
	java.util.Date是java.sql.Date,java.sql.Time,java.sql.Timestamp的父类
	所以java.util.Date可以对应SQL数据库中三种时间。
	如果对象类型定义为java.util.Date要区别是那种格式时间，在*.hbm.xml配置中property节点的type定义为Hibernate的类型
		eg.<property name="date" type="date/time/timestamp">    而不是type=java.util.Date
	            <column name="DATE" />
	        </property>


插播：将图片变为Blob类型
	Blob blob = new SerialBlob(byte[]);  这样可以将byte变为Blob
	或者
	Blob blob = Hibernate.getLobCreator(session).createBlob(is,is.available());

描述组成关系：Work由Pay和其他变量组成，少了Pay不行
使用Work包含Pay类的方式生成一张表Work，其中有Pay的字段
	Work.java,Pay.java,Work.hbm.xml
	Work.hbm.xml加入Pay方式：
		<!-- 映射组成关系 -->
		<component name="pay" class="Pay">
			<!-- 指定组成关系的组件属性 -->
			<property name="monthlyPay" type="int"></property>
			<property name="yearPay" type="int"></property>
		</component>  
	表结构如下：
	CREATE TABLE `work` (
	  `ID` int(11) NOT NULL AUTO_INCREMENT,
	  `monthlyPay` int(11) DEFAULT NULL,
	  `yearPay` int(11) DEFAULT NULL,
	  PRIMARY KEY (`ID`)
	)	
		
单向一对多关系：relationship.n21
	Customer,Order  一个客户可以拥有多个订单  1对N
	表现为代码形式就是Customer类中没有Order对象，Order类中有Customer对象
	
	Order类中有Customer
		private Customer customer;   仅仅查询Order此时Customer对象返回代理类，延迟加载Customer
	Order.hbm.xml中：
		<!-- 
        	映射多对一的关联关系
        	Customer表的ID： CUSTOMER_ID 此处是外键  Customer.hbm.xml -->  <column name="CUSTOMER_ID" />
        	name: 多的一端关联一的一端Order类中的属性名
        	class:一的一端对应类（com.lw.hibernate.relationship.n21.Customer）
         -->
        <many-to-one name="customer" class="Customer" column="CUSTOMER_ID"></many-to-one>
   
	数据库表中表现为有一个customer和orders表，orders表的外键为customer_id

双向一对多关系: relationship.n21_both
	双向一对多表现为代码形式为： Customer中有Order的集合订单关系，Order类中有Customer对象
	Customer:
		/*
		 * 此处集合初始化为了防止空指针异常
		 */
		private Set<Order> orders = new HashSet<Order>();
	Customer.hbm.xml:
		<!-- 
        	映射1对多的集合属性
        	name: 是Customer类中定义的集合名字 Set<Order> orders
        	table: Order.hbm.xml中对应表名
        	key 表示orders表中外键  和 Order.hbm.xml中many-to-one节点填写的column属性一致
        	one-to-many 表示一对多关系 class是全类名（com.lw.hibernate.relationship.n21_both.Order）
         
         	inverse 表示放弃维护关联关系，此时就不会因为Order表更新Customer
         	
         	cascade: 设定级联操作
         				delete 级联删除 
         				delete-orphan 删除集合orders中元素会同步删除ORDERS表记录
         				save-update  级联保存更新，保存customer时会同步保存集合中order
         				all: 所有情况下均进行关联操作，即save-update和delete。
　　　　　　　　　　			none: 所有情况下均不进行关联操作。这是默认值。 
			order-by: 查询时排序方式 ，此处是ORDERS表的列名，不是Order类中的名字
         -->
        <set name="orders" table="ORDERS" inverse="true" cascade="delete" order-by=" ORDER_NAME desc">
        	<key column="CUSTOMER_ID"></key>
        	<one-to-many class="Order"></one-to-many>
        </set>
        
    Order类，和Order.hbm.xml同单向一对多关系
   	 数据库表表现形式同单向一对多关系    
	
外键方式一对一映射关系：one2one_foreign
	一个部门拥有一个部门经理，一个部门经理管理一个部门   Manager,Department
	Manager类中包含Department:
		private Department dept;
	Manager.hbm.xml：
		<!-- 
        	此处使用one-to-one是因为在Department.hbm.xml中已经有了外键映射关系
        	
        	property-ref: manager表中mgr_id使用department类中manager属性对应的数据表列(mgr_id)作为关联条件
        					否则就关联department表的主键——dept_id
         -->
        <one-to-one name="dept" class="Department" property-ref="manager"></one-to-one>	
	Department类中有Manager对象：
		private Manager manager;
	Department.hbm.xml:
		<!-- 使用many-to-one映射一对一关系 -->
		<many-to-one name="manager" class="Manager" column="MGR_ID" unique="true"></many-to-one>
	注意： 这里使用many-to-one映射关系如何形成一对一呢？ 关键点在于unique="true" 表示这个外键mgr_id是唯一的	

	数据表表现形式为：一个manager表，一个department表，department表中有一个unique的外键mgr_id

基于主键方式一对一关系：one2one_primary
	基于主键就是manager表的mgr_id和department表的dept_id相等，dept_id即是department表的主键也是外键，关联manager的mgr_id

	Manager,Department类结构不变
		Manager.hbm.xml: 不再需要指定property-ref属性
			<one-to-one name="dept" class="Department"></one-to-one>
	Department.hbm.xml:
		<id name="deptId" type="java.lang.Integer">
            <column name="DEPT_ID" />
            <!-- 
            	使用外键的方式生成主键
             -->
            <generator class="foreign">
            	<!-- 指定当前department类的manager属性的主键作为外键 -->
            	<param name="property">manager</param>   ------->这里就指定dept_id的值使用manager对象的mgr_id的值
            </generator>
        </id>
	
		<!-- 
			constrained: true 表示在 generator节点表示 class为foreign中添加外键约束
		-->
		<one-to-one name="manager" class="Manager" constrained="true"></one-to-one>
		注意： 如果没有constrained="true"，那么生成的dept_id就没有foreign_key这个外键约束，虽然依旧会生成manager和department表，运行也正常

单向多对多关系映射：n2n下
	一个商品目录对应多种商品，一个商品也可能包含在多种商品目录中  Category,Item
	Category中含有Item:
		private Set<Item> items = new HashSet<Item>();
	Category.hbm.xml:
		<!-- 
        	CATEGORIES_ITEMS  many-to-many需要生成的中间表
        	C_ID 这个是此中间表的外键,对应Categories表的ID 
         -->
        <set name="items" table="CATEGORIES_ITEMS" inverse="false" lazy="true">
            <key>
                <column name="C_ID" />
            </key>
            <!-- 此处是Set<Item> items集合对应在中间表的外键名称 -->
            <many-to-many class="Item" column="I_ID"/>  -------->这里和双向一对多唯一不同之处在于不是one-to-many而是many-to-many
        </set>	

	Item中不包含Category
	
	数据库会生成三个表categrories,items和中间表 categories_items

双向多对多关系映射：n2n_both
	其他不变唯一不同于单向多对多就是Item包含Category的集合：
	Item:
		private Set<Category> categories = new HashSet<Category>();
	Item.hbm.xml:
		<!-- 
        	inverse=true：是因为Category.hbm.xml为false，由categories表维护主键关系
        	若是这里也维护可能会主键冲突  报错为：ConstraintViolationException
        	table 此属性需要和Category.hbm.xml一致
         -->
        <set name="categories" table="CATEGORIES_ITEMS" inverse="true">
        	<key>
        		<!-- 此处的I_ID需要和Category.hbm.xml中设置的many-to-many节点属性column一致 -->
        		<column name="I_ID"></column>
        	</key>
        	<!-- C_ID 需要和Category.hbm.xml中column节点的name属性一致 -->
        	<many-to-many class="Category" column="C_ID"></many-to-many>
        </set>
                      这里要注意Categrory.hbm.xml和Item.hbm.xml只能有一个是inverse=false
	
